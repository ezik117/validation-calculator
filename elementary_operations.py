# *****************************************************************************
# МОДУЛЬ:    -
# ФАЙЛ:      ELEMENTARY_OPERATIONS.PY
# ЗАГОЛОВОК: ЭЛЕМЕНТАРНЫЕ АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ ВЫСОКОЙ ТОЧНОСТИ
# ОПИСАНИЕ:  Содержит реализацию основных математических операций на языке
#            Python (сложение, вычитание, умножение, деление).
#            Операции выполнены с использованием хранения чисел в строках и
#            алгоритм выполнен таким образом что можно задать высокую точность
#            десятичной дроби (более 15 чем у стандарного double). Точность
#            ограничивается только максимально возможной длиной строки (для 
#            Python x64 это 64Гб памяти (размер строки зависит от типа кодировки))
#            Числа хранятся в обычной записи (т.е. без использования мантиссы)
# *****************************************************************************


# реализация сложения методом в столбик (только беззнаковые числа)
# IN: A, B - строки чисел включая дробные
# IN: precision - количество десятичных цифр после запятой (по умолчанию 15),
#                 последний разряд округляется
# OUT: возвращает строку с числом
# ПРИМЕР: print(elementaryAdd("800.5158525461314613", "20.1", 13)) => 820.6158525461315
def elementaryAdd(A:str, B:str, precision:int = 15):
	result = ""

	# защита проверки ввода параметров
	if precision < 0:
		precision = 0
	try:
		x = float(A) + float(B)
	except:
		return "Error"

	# переведем строковые числа в 1-байтовое хранение, для ускорения обработки
	A = A.encode('Latin-1')
	B = B.encode('Latin-1')
		
	# добавим десятичную часть если нет, нужно для единства подхода обработки как дробных так и целых чисел
	if A.find('.') < 0: A += ".0"
	if B.find('.') < 0: B += ".0"

	# получим целые и дробные части
	intA, fracA = A.split('.')
	intB, fracB = B.split('.')

	# выровняем части по длине, для подсчета в столбик
	intA = intA.rjust(len(intB), '0')
	intB = intB.rjust(len(intA), '0')
	fracA = fracA.ljust(len(fracB), '0')
	fracB = fracB.ljust(len(fracA), '0')

	# соберем обратную строку, т.к. считать в столбик будем с конца, это просто удобно
	a = (intA + '.' + fracA)[::-1]
	b = (intB + '.' + fracB)[::-1]

	# считаем в столбик поэлементно
	carry = 0
	for iA, iB in zip(a, b):
		if iA != '.':
			c = str(int(iA) + int(iB) + carry)
			if len(c) > 1:
				carry = 1
				c = c[-1]
			else:
				carry = 0
			result += c
		else:
			result += '.'
	# добавим разряд, если сумма последних элементов вызвала перенос
	if carry == 1:
		result += "1"

	# соберем прямую строку из обратной
	result = result[::-1]

	# получим целую и дробную части
	intR, fracR = result.split('.')

	# округлим до точного значения
	if precision > 0:
		# если точность была задана для дробной части
		if len(fracR) > precision:
			if int(fracR[precision]) > 5:
				lastChar = str(1 + int(fracR[precision - 1]))
				fracR = fracR[:precision - 1] + lastChar
			else:
				fracR = fracR[:precision]

		# Удалим правые нули в дробной части
		while fracR and fracR[-1] == '0':
			fracR = fracR[:-1]
			
		# для точности до десятой
		result = intR + (f'.{fracR}' if fracR else '')
	else:
		# для точности до целой цести
		result = str(int(intR) + (1 if int(fracR[0]) > 5 else 0))

	return result


# -------------------------------------------------------------------------------------------------
def elementarySub(A:str, B:str, precision:int = 15):
	pass

# -------------------------------------------------------------------------------------------------
def elementaryMul(A:str, B:str, precision:int = 15):
	pass

# -------------------------------------------------------------------------------------------------
def elementaryDiv(A:str, B:str, precision:int = 15):
	pass